###### 前言

工作窃取（work-stealing）是并行编程中的一种线程调度策略，语言社区有很多运行时库都实现了这种调度策略，例如rust社区的rayon、tokio，c++的parlaylib、Java的util.concurrent。这篇文章讲解工作窃取的原理和实现。

**原理**

child stealing：在执行线程之前先创建全部的n个任务，如果没有小偷线程可用。

continuation stealing：源线程执行f(i)在让迭代进入下一步之前。如果有小偷线程可用，源线程可以将循环进入下一次迭代，创建一个任务，让循环处于可被窃取的状态并且由下一个小偷线程将循环的迭代次数加一。因此任务数量不会超过并行执行的线程数量。

child stealing不会限制线程的创建数量。

join后执行哪个线程？stalling策略和贪心策略。stalling策略，相同的线程会发起fork操作，等待其他线程执行完毕。贪心策略，最后一个线程到达join时机时会继续执行。

假设有两个进程P1，P2.父线程运行在P1上，子线程由父线程唤起。现在我们有两个任务需要做，一个是父线程的其余部分，一个是子线程。

child stealing：P1继续执行父线程的剩余任务，将子线程放入调度其中。P2还没有任务可做，检查其他进程的调度器，看到了子线程。P2偷取子线程，执行它。

continuation stealing：P1继续执行父线程的其余代码，P1执行子线程，将父线程的其余代码放入调度器中。这些剩余代码就是continuation，P2看到了P1调度器中的continuation，P1窃取continuation然后执行它。
