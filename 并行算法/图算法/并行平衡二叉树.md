###### 前言

笔者阅读孙艺瀚的博士论文时做的笔记，这篇只是做一些简单的总结性概括，不涉及具体的论证细节。

###### 并行平衡二叉树

~~尽管我们可以使用基础数据结构，比如数组或链表维护ordering（因为实际应用中，树结构都是有序集合。），树是更高效的数据结构在维护动态数据方面。**O**„**log**n**”**，查找、插入单个、删除、更新。~~

~~树结构的特例，数据中的顺序关系允许一些partition非常高效，一些几何算法也依赖这些partition操作，比如segment tree、range tree、kd-tree。~~

并行化的平衡二叉树中的一个核心操作就是join($T_L,e,T_R$)，join操作接受一棵平衡二叉树的左右子树以及pivot（不太好翻译，基本可以理解为一个起点），返回一个新的二叉树。虽然从描述上还看不出join操作有什么复杂的地方，神奇的是它可以应用于不同的平衡二叉树变体，比如AVL树、红黑树、加权平衡树、树堆（treap）。这些变体都可以通过增广BST实现，但我不会在本篇谈论增广的数学形式，我想从技术细节上简明扼要地描述它：二叉树的增广是指树中的每个节点都存储它的子树的一些信息。


join操作内部就做了增广，除此以外还包括重平衡和持久化，重平衡就是根据不同的二叉树变体计算它的rank，例如AVL树是计算树的高度、加权平衡树是取树的大小的对数。持久化实现了路径拷贝（path-copying）算法，只复制其中受到影响的节点路径，具体的效果见图1。


join操作内部分开来看，做了三个工作：重平衡、增广、持久化，重平衡这步是根据不同二叉树变体的rank来调整，增广是说在二叉树中的每个节点存储关于子树的一些信息，


应用了分治的思想，二叉树相关的许多操作都可以调用

都可以分类到基于join操作的树算法，join($T_L,e,T_R$)做了三个工作：重平衡、增广、持久化。

join对的结果返回的是新的二叉树。join($T_L,e,T_R$)

论文中列举了一些二叉树相关的操作以及它们的work-span度量，。


基于join操作的树算法可以并行地实现一类平衡二叉树，

AVL树、红黑树、加权平衡树、树堆（treap）等平衡二叉树变体都可以通过增广BST的方式实现。

**P-Tree **实现这些平衡二叉树的不同增广，至少包含四种：AVL树、红黑树、加权平衡树、treap。

join($T_L,e,T_R$)对每个平衡二叉树的变体，给定一棵平衡二叉树的左右子树以及pivot，join操作后得到一个新的平衡二叉树。join操作具体的工作包含再平衡、增广、持久化，每个变体都定义一个rank函数，对于AVL树是计算树的高度、加权平衡树是取树的大小的对数。之后定义一套规则以及join算法让每个变体都是joinable的。

定义（强可连接树） 一个平衡树方案S是强可连接的，如果可以对S中的每个子树给出一个rank，在S的两个子树T1、T2上存在一个join(T1,e,T2)，满足以下规则：

1.空规则：树为空时rank是0

2.单调规则：对于$C=join(A,e,B)$，$max(rank(A),rank(B) \leq rank(C))$

3.子模块规则：假设$C=node(A,e,B)$、$C'=join(A',e,B')$。如果$0 \leq rank(A')-rank(A) \leq 0$ 、$0 \leq rank(B')-rank(B) \leq x$ ，那么$0 \leq rank(C')-rank(C) \leq x$ （增长）。如果$0 \leq rank(A)-rank(A')$ 、$0 \leq rank(B)-rank(B')$ ，那么$0 \leq rank(C)-rank(C')$ （下降）

4.复杂度规则：join($A,e,B$)的时间复杂度是$O(|rank(A)-rank(B)|)$ 。

5.平衡规则：对于一个节点A，$max(rank(lc(A)),rank(rc(A)))+c_1 \leq rank(A) \leq min(rank(lc(A)),rank(rc(A)))+c_u$，$c_1<=1$、$c_u>=1$且都是常数。

定义（弱可连接树） 一个平衡树方案S是弱可连接的，如果它满足空规则、单调规则以及子模块规则，且满足如下规则：

1.宽松平衡规则：存在常数$c_l$、$c_r$、$0<p_l<=1$且$0<p_u<=1$，对节点A以及该节点的任一子节点B满足：

$rank(B)<=rank(A)-c_l$成立的概率至少为$p_l$

$rank(B)>=rank(A)-c_u$成立的概率至少为$p_u$

2.弱复杂度规则：高概率满足join(A,e,B)的时间复杂度为$O(rank(A)+rank(B))$

定义 可连接树中，节点T位于i层，如果$i<=rank(T)<i+1$

定义 可连接树中，节点v是rank/rank(i)的根，如果v在i层且v的父节点不在i层。

定义 在BST中，节点集合V是无祖先的，当且仅当对于$V$中的任意两个节点$v_1$、$v_2$，$v_1$不是$v_2$的祖先。

论文中给出了四种平衡树性质的证明，结论是AVL树、红黑树、加权平衡树是强可连接的，树堆是弱可连接的。

不过，要实现join操作还是需要一些技巧的，为了方便并行化，定义两个辅助函数$split(T,k)$和$join2(T_l,T_r)$，详细说明写在注释中了。


增广操作包含很多，像各种“求和”（论文这里就是加引号的，就是满足结合律的函数），比如加法、最大值、union等。在具体的细节上，这些增广操作就是每个节点存储一些关于子树的信息。


使用join操作让树持久化，是说任何的更新都会产生一个新的树同时保留旧的树。持久化就是保留树的历史记录，允许对树的并发控制。持久化应用在数据库系统中的快照隔离，计算几何的扫描线算法（算法在每个事件点更新数据结构）以及事务（transactional）系统（数据库系统中的MVCC（multi-version concurrency control），例如并发更新和并发查询）等，持久化功能使用路径拷贝（path-copying）复制受影响的路径（算法最多需要$O(logn))$，这种方法是无锁的原子操作。

| 函数                                                                                                         | work               | span            |
| ------------------------------------------------------------------------------------------------------------ | ------------------ | --------------- |
| insert, delete, update, find, first, last, range, split, join2, previous, next, rank, select, up_to, down_to | $O(logn)$        | $O(logn)$     |
| union, intersection, difference                                                                              | $O(mlog(n/m+1))$ | $O(lognlogm)$ |
| map, reduce, map_reduce, to_array                                                                            | $O(n)$           | $O(logn)$     |
| build, filter                                                                                                | $O(n)$           | $O(log^2n)$   |


这些树操作都可以看作是基于join的操作，join函数是接受左右子树以及pivot，返回一个新的平衡二叉树。
