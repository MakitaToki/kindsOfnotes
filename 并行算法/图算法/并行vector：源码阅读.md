### 前言

PRAM模型（主要不是谈PRAM的种类，我关心的是怎么实现互斥的。是不是无锁的。）

### 算法描述

~~1D block mapping操作partition顶点集合$V$为$p$个子集，每个线程都获得一个距离数组，~~

~~Dijkstra原始算法是找到两个顶点之间的最短路径，当然也可以用于找一个源点到其余节点的最短路，这构造了一个最短路树。当图是无权图时，最短路树就是宽度优先搜索树。~~

### 优先级队列

~~最小堆、最大堆属于最常见的实现方式了，另外平衡二叉搜索树（下文简称平衡BST）也可以用于实现优先级队列，此时插入和删除操作需要$O(log n)$，建堆需要$O(n log n)$。笔者选用了平衡BST实现，当然是因为我只熟悉这个数据结构。~~

~~简单讲一讲并行版的平衡BST。并行化的Dijkstras算法不支持一次性删除多个元素，过程中从队列中取出最小距离的节点，重新计算该节点所有相邻节点的距离，~~

~~在共享内存模型的执行环境，并行化的优先级队列可以使用BST以及基于join操作的树算法实现。k_extract_min是删除k个最小元素，在BST上对应于分割操作。$O(\log n)$，生成一个树包含k个最小的元素。k_insert可以用union操作实现两棵树的合并，如果batch已经按大小关系排序，![{\textstyle O(k\log(1+{\frac {n}{k}}))}](https://wikimedia.org/api/rest_v1/media/math/render/svg/42eca403362de73c25092dc6e2490d9a4093a6df)。k_decrease_key可以借助difference和union操作完成，就是先从树中删除它们再插入回来。~~

### k个元素的操作
