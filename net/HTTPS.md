### 为什么要有HTTPS？


* **机密性** ：报文加密，TLS
* **完整性** ，HTTP协议无身份认证，可能遭遇中间人攻击，导致报文被篡改。
* ~~**身份认证** ，数字签名有效避免中间人攻击。~~

### 什么是SSL/TLS

### HTTPS是如何解决上面的三个风险的呢？

#### 通过混合加密，保证了信息的机密性

按照密钥的使用方式，常见加密有两种方式：对称加密和非对称加密。

对称加密指加密和解密使用同一密钥

非对称加密 私钥 ，公钥 。使用方式是：**发送方将报文用公钥进行加密处理，对方收到后用私钥进行 解密 ，也不用担心密钥被攻击者窃听而盗走。**

所以HTTPS利用了两者的优势，将两种方式组合起来用于通信。**在交换密钥阶段使用非对称加密的方式，之后建立通信交换报文阶段则使用对称加密方式。**

#### 摘要算法用来实现完整性

哈希函数，~~用于校验数据的完整性。客户端在发送数据之前通过摘要算法算出明文的 **指纹** ，发送的时候将**明文+指纹**一同加密~~


### HTTPS链接的建立过程

1. 浏览器发送**Client Hello**消息，信息如下：
   * 客户端支持的SSL/TLS版本号，如TLS1.2版本
   * 支持的密码套件，如ECDHE
   * 客户端产生的**随机数**C，用于生成后续的会话密钥
2. 

服务器收到Client Hello消息后，会发送**Server Hello**

* 确实SSL/TLS协议版本，如果浏览器不支持，则关闭加密通信
* 确认密码套件列表，选择最合适的加密算法，如ECDHE
* 服务器产生的**随机数**S，用于生成后续的会话密钥
* 服务端为了证明身份，把证书也发送给客户端

3.客户端回应，Client Key Exchange。客户端收到服务器的消息后，用浏览器或者系统中的CA公钥验证数字证书的真实性，如果证书没问题，客户端从数字证书中取出服务器的 **公钥** ，用其加密报文。

4. 
5. 服务器的最后回应。
   * 加密通信算法改变通知
   * Finished消息，结束通知。把之前所有发送的数据做一个摘要再加密一下，让客户端做验证

**安全攻击**

怎么保证通信双方没有中间人？HTTPS 之所以能这样保证，是因为它使用的是 **符合X.509标准的证书[1]** ，而不仅仅是公钥和私钥。

## 用非对称加密可行吗？

服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！ **因为只有服务器有相应的私钥能解开公钥加密的数据** 。

## ~~**改良的非对称加密方案，似乎可以？**~~

~~我们已经理解通过一组公钥私钥，可以保证单个方向传输的安全性，那用两组公钥私钥，是否就能保证双向传输都安全了？请看下面的过程：~~

1. ~~某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。~~
2. ~~浏览器把公钥B明文传输给服务器。~~
3. ~~服务器把公钥A明文给传输浏览器。~~
4. ~~之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。~~
5. ~~同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。~~

## **非对称加密+对称加密？**

这种方法仍然有漏洞。

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可

**中间人攻击**

![](https://pic2.zhimg.com/80/v2-daeb6b8b0ac5411d51d60bd08b551789_720w.jpg)
中间人攻击（https://blog.pradeo.com/man-in-the-middle-attack）

如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它，然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：

1. 某网站有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. **中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）** 。
4. 浏览器生成一个用于对称加密的密钥X，用 **公钥B** （浏览器无法得知公钥被替换了）加密后传给服务器。
5. **中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器** 。
6. 服务器拿到后用私钥A’解密得到密钥X。
